# -*- coding: utf-8 -*-
# Generated by Django 1.10.5 on 2017-03-19 17:34
from __future__ import unicode_literals

from django.db import migrations

from modules.entrance import models as entrance_models
from modules.poldnev import models as poldnev_models
from users import search_utils

import sys
import re


def _equals_with_replaced_yo(s1, s2):
    return s1.lower().replace('ё', 'е') == s2.lower().replace('ё', 'е')


def _safe_update_name(user_profile, person):
    if not _equals_with_replaced_yo(user_profile.first_name, person.first_name):
        user_profile.first_name = person.first_name
    if not _equals_with_replaced_yo(user_profile.last_name, person.last_name):
        user_profile.last_name = person.last_name
    if not _equals_with_replaced_yo(user_profile.middle_name, person.middle_name):
        user_profile.middle_name = person.middle_name


class EnrolledPoldnevPersonDetector(object):
    UserModel = None
    UserProfileModel = None
    PoldnevPersonModel = None

    _all_persons = []

    _detected = 0
    _already_detected = 0

    def generate_all(self, apps, schema_editor):
        self.UserModel = apps.get_model('users', 'User')
        self.UserProfileModel = apps.get_model('users', 'UserProfile')
        self.PoldnevPersonModel = apps.get_model('poldnev', 'Person')

        for entrance_status in entrance_models.EntranceStatus.objects.filter(
                status=entrance_models.EntranceStatus.Status.ENROLLED).all():
            user = entrance_status.user
            if not user.is_active:
                raise Exception('Enrolled user(%d %s) was deactivated by some reason' % (user.id, str(user)))
            if not hasattr(user, 'user_profile'):
                continue
            if entrance_models.AbstractAbsenceReason.for_user_in_school(user, entrance_status.school):
                continue
            user_profile = user.user_profile

            if hasattr(user, 'poldnev_person'):
                self._already_detected += 1
                continue

            person = self._search_for_poldnev_person(user, user_profile, entrance_status.school)

            if not person:
                continue

            # sys.stdout.write('{}, {}, {}\n'.format(user, user_profile, person))

            person_model = self.PoldnevPersonModel.objects.get(pk=person.pk)
            user_model = self.UserModel.objects.get(pk=user.pk)
            user_profile_model = self.UserProfileModel.objects.get(pk=user_profile.pk)

            person_model.user = user_model
            person_model.save()
            user_profile_model.poldnev_person = person_model
            _safe_update_name(user_profile_model, person_model)
            user_profile_model.save()
            self._detected += 1

            sys.stdout.flush()

        sys.stderr.write("%d detected, %d already detected\n" % (self._detected, self._already_detected))

    @classmethod
    def _match_poldnev_person_name(cls, person, user_profile):
        return (search_utils.match_last_names(person.last_name, user_profile.last_name)
                and search_utils.match_first_names(person.first_name, user_profile.first_name))

    @classmethod
    def _match_poldnev_person_middle_name(cls, person, user_profile):
        return search_utils.match_middle_names(person.middle_name, user_profile.middle_name)

    @classmethod
    def _match_poldnev_person_school(cls, person, school):
        return person.history_entries.filter(role__session__schools_session__school=school).exists()

    def _search_for_poldnev_person(self, user, user_profile, school):
        if not self._all_persons:
            self._all_persons = list(poldnev_models.Person.objects.all())
        persons = [person for person in self._all_persons if self._match_poldnev_person_name(person, user_profile)]
        if len(persons) > 1:
            persons = [person for person in persons if self._match_poldnev_person_middle_name(person, user_profile)]
        if len(persons) > 1:
            persons = [person for person in persons if self._match_poldnev_person_school(person, school)]
        if len(persons) == 0:
            sys.stdout.write('Can not detect poldnev.Person for (user %s, profile %s)\n' % (str(user), str(user_profile)))
            return None
        if len(persons) > 1:
            raise Exception('Found too many poldnev.Persons for user %s' % str(user))
        return persons[0]

    @classmethod
    def as_callable(cls):
        def func(*args, **kwargs):
            cls().generate_all(*args, **kwargs)

        return func


class Migration(migrations.Migration):

    dependencies = [
        ('users', '0011_create_user_profiles_for_enrolled'),
        ('poldnev', '0007_auto_20170318_1027'),
    ]

    operations = [
        migrations.RunPython(EnrolledPoldnevPersonDetector.as_callable(), migrations.RunPython.noop),
    ]